#!/usr/bin/python
#
# Copyright (C) 2011-2012  Codethink Limited
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


import cliapp
import json
import logging
import os

import morphlib
from morphlib import buildworker
from morphlib import buildcontroller
from morphlib.morphologyloader import MorphologyLoader
from morphlib.builddependencygraph import BuildDependencyGraph


defaults = {
    'git-base-url': [
        'git://gitorious.org/baserock-morphs/',
        'git://gitorious.org/baserock/',
    ],
    'cachedir': os.path.expanduser('~/.cache/morph'),
    'max-jobs': morphlib.util.make_concurrency(),
    'prefix': '/usr',
    'toolchain-target': '%s-baserock-linux-gnu' % os.uname()[4],
}


class Morph(cliapp.Application):

    def add_settings(self):
        self.settings.boolean(['verbose', 'v'], 'show what is happening')
        self.settings.string_list(['git-base-url'],
                             'prepend URL to git repos that are not URLs',
                             metavar='URL',
                             default=defaults['git-base-url'])
        self.settings.string(['bundle-server'],
                             'base URL to download bundles',
                             metavar='URL')
        self.settings.string(['cachedir'], 
                             'put build results in DIR',
                             metavar='DIR', 
                             default=defaults['cachedir'])
        self.settings.string(['prefix'],
                             'build chunks with prefix PREFIX',
                             metavar='PREFIX', default=defaults['prefix'])
        self.settings.string(['toolchain-target'],
                             'set the TOOLCHAIN_TARGET variable which is used '
                             'in some chunks to determine which architecture '
                             'to build tools for',
                             metavar='TOOLCHAIN_TARGET',
                             default=defaults['toolchain-target'])
        self.settings.string(['target-cflags'],
                             'inject additional CFLAGS into the environment '
                             'that is used to build chunks',
                             metavar='CFLAGS',
                             default='')
        self.settings.string(['tempdir'],
                             'temporary directory to use for builds '
                                '(this is separate from just setting $TMPDIR '
                                'or /tmp because those are used internally '
                                'by things that cannot be on NFS, but '
                                'this setting can point at a directory in '
                                'NFS)',
                             metavar='DIR', 
                             default=os.environ.get('TMPDIR'))
        self.settings.boolean(['no-ccache'], 'do not use ccache')
        self.settings.boolean(['no-distcc'], 'do not use distcc')
        self.settings.integer(['max-jobs'], 
                              'run at most N parallel jobs with make (default '
                                'is to a value based on the number of CPUs '
                                'in the machine running morph',
                              metavar='N',
                              default=defaults['max-jobs'])
        self.settings.boolean(['keep-path'], 
                              'do not touch the PATH environment variable')
        self.settings.boolean(['bootstrap'], 
                              'build stuff in bootstrap mode; this is '
                                'DANGEROUS and will install stuff on your '
                                'system')
        self.settings.boolean(['ignore-submodules'],
                              'do not cache repositories of git submodules '
                              'or unpack them into the build directory')

        self.settings.boolean(['no-git-update'],
                              'do not update the cached git repositories '
                                'during a build (user must have done that '
                                'already using the update-gits subcommand)')

        self.settings.string_list(['staging-filler'],
                                  'unpack BLOB into staging area for '
                                    'non-bootstrap builds (this will '
                                    'eventually be replaced with proper '
                                    'build dependencies)',
                                   metavar='BLOB')
        self.settings.boolean(['staging-chroot'],
                              'build things in a staging chroot '
                                '(require real root to use)')

        self.settings.string_list(['worker'],
                                  'IP or host name of a machine to distribute '
                                  'build work to',
                                  metavar='HOSTNAME')

    def _itertriplets(self, args):
        '''Generate repo, ref, filename triples from args.'''
        
        if (len(args) % 3) != 0:
            raise cliapp.AppException('Argument list must have full triplets')
        
        while args:
            assert len(args) >= 2, args
            yield args[0], args[1], args[2]
            args = args[3:]


    def cmd_build(self, args):
        '''Build a binary from a morphology.
        
        Command line arguments are the repository, git tree-ish reference,
        and morphology filename. Morph takes care of building all dependencies
        before building the morphology. All generated binaries are put into the
        cache.
        
        (The triplet of command line arguments may be repeated as many
        times as necessary.)
        
        '''


        if not os.path.exists(self.settings['cachedir']):
            os.mkdir(self.settings['cachedir'])

        for repo, ref, filename in self._itertriplets(args):
            tempdir = morphlib.tempdir.Tempdir(self.settings['tempdir'])
            morph_loader = MorphologyLoader(self.settings)
            source_manager = morphlib.sourcemanager.SourceManager(self,
                                update=not self.settings['no-git-update'])
            factory = morphlib.builder.Factory(tempdir)
            builder = morphlib.builder.Builder(tempdir, self, morph_loader,
                                               source_manager, factory)

            # Unpack manually specified build dependencies.
            factory.create_staging()
            for bin in self.settings['staging-filler']:
                factory.unpack_binary_from_file(bin)

            # derive a build order from the dependency graph
            graph = BuildDependencyGraph(source_manager, morph_loader,
                                         repo, ref, filename)
            graph.resolve()
            blobs, order = graph.build_order()

            self.msg('Building %s|%s|%s' % (repo, ref, filename))

            # build things in this order
            builder.build(order)

            tempdir.remove()

    def cmd_show_dependencies(self, args):
        '''Dumps the dependency tree of all input morphologies.'''

        morph_loader = MorphologyLoader(self.settings)
        source_manager = morphlib.sourcemanager.SourceManager(self,
                            update=not self.settings['no-git-update'])

        for repo, ref, filename in self._itertriplets(args):
            # create a dependency graph for the morphology
            graph = BuildDependencyGraph(source_manager, morph_loader,
                                         repo, ref, filename)
            graph.resolve()

            # print the graph
            self.output.write('dependency tree:\n')
            for blob in sorted(graph.blobs, key=str):
                self.output.write('  %s\n' % blob)
                for dependency in sorted(blob.dependencies, key=str):
                    self.output.write('    -> %s\n' % dependency)

            # compute a build order from the graph
            blobs, order = graph.build_order()
            self.output.write('build order:\n')
            for group in order:
                self.output.write('  group:\n')
                for blob in sorted(group, key=str):
                    self.output.write('    %s\n' % blob)

    def cmd_update_gits(self, args):
        '''Update cached git repositories.

        Parse the given morphologies, and their dependencies, and
        update all the git repositories referred to by them in the
        morph cache directory.
        
        '''

        morph_loader = MorphologyLoader(self.settings)
        source_manager = morphlib.sourcemanager.SourceManager(self)

        for repo, ref, filename in self._itertriplets(args):
            # resolve the dependency graph, which will implicitly
            # clone all repositories needed to build the blob
            graph = BuildDependencyGraph(source_manager, morph_loader,
                                         repo, ref, filename)
            graph.resolve()

    def cmd_build_single(self, args):
        '''Build a binary from a morphology but do not build its dependencies.
        
        To build a system or stratum morphology, simply specify the repository,
        a git tree-ish reference and the morphology filename on the command
        line. To build a chunk morphology, first provide the repository,
        reference and morphology filename of its surrounding stratum and then
        provide the same information for the chunk morphology itself. This is
        needed to resolve the dependencies of the chunk using the stratum as
        the build context and to unpack these dependencies in the staging area
        prior to building the chunk.

        This command differs from 'build' in that it only builds the morphology
        specified on the command line. Dependencies are assumed to have been
        built prior to running this command and are only unpacked into the
        staging area.

        '''
        tempdir = morphlib.tempdir.Tempdir(self.settings['tempdir'])
        morph_loader = MorphologyLoader(self.settings)
        source_manager = morphlib.sourcemanager.SourceManager(self,
                                                              update=False)
        factory = morphlib.builder.Factory(tempdir)
        builder = morphlib.builder.Builder(tempdir, self, morph_loader,
                                           source_manager, factory)

        if not os.path.exists(self.settings['cachedir']):
            os.mkdir(self.settings['cachedir'])

        factory.create_staging()

        if len(args) >= 3:
            repo, ref, filename = args[:3]
            args = args[3:]

            # derive a build order from the dependency graph
            graph = BuildDependencyGraph(source_manager, morph_loader,
                                         repo, ref, filename)
            first_blob = graph.resolve()
            blobs, order = graph.build_order()

            # parse the second blob, if there is one
            second_blob = None
            if len(args) >= 3:
                repo, ref, filename = args[:3]
                args = args[3:]

                # load the blob manually
                treeish = source_manager.get_treeish(repo, ref)
                morphology = morph_loader.load(treeish, filename)
                second_blob = morphlib.blobs.Blob.create_blob(morphology)

                try:
                    # find the corresponding blob object in the blobs
                    # returned from the dependency graph
                    second_blob = [x for x in blobs if x == second_blob][0]
                except IndexError:
                    raise cliapp.AppException('%s and %s are unrelated' %
                                              (first_blob, second_blob))

            # build the single blob
            if second_blob:
                # verify that the two input blobs are valid
                if first_blob.morph.kind != 'stratum':
                    raise cliapp.AppException('The first tuple %s needs to '
                                              'refer to a stratum' %
                                              first_blob)
                if second_blob.morph.kind != 'chunk':
                    raise cliapp.AppException('The first tuple %s needs to '
                                              'refer to a chunk' % second_blob)

                # build now
                self.msg('Building %s' % second_blob)
                builder.build_single(second_blob, order)
            else:
                # build the blob now
                self.msg('Building %s' % first_blob)
                builder.build_single(first_blob, order)

        tempdir.remove()

        if args:
            raise cliapp.AppException('Extra args on command line: %s' % args)

    def cmd_build_distributed(self, args):
        '''Build a binary from a morphology, distributing work where possible.
        
        Command line arguments are the repository, git tree-ish reference,
        and morphology filename. Morph takes care of building all dependencies
        before building the morphology. All generated binaries are put into the
        cache.

        This command differs from 'build' in that it distributes work to
        other machines where possible. This may include preparing the source
        tree, preparing the staging area, building individual chunks and
        caching the built items.
        
        Distributing currently works by running 'morph build-single' on other
        machines via SSH. The machines to be used for this are specified using
        the '-w/--worker' command line options.
        
        (The triplet of command line arguments may be repeated as many
        times as necessary.)

        '''
        
        tempdir = morphlib.tempdir.Tempdir(self.settings['tempdir'])
        morph_loader = MorphologyLoader(self.settings)
        source_manager = morphlib.sourcemanager.SourceManager(self,
                                update=not self.settings['no-git-update'])

        # create a build controller
        controller = buildcontroller.BuildController(self, tempdir)

        # create and add the build workers
        if len(self.settings['worker']) == 0:
            num_workers = morphlib.util.make_concurrency()
            for i in range(num_workers):
                name = controller.generate_worker_name('local')
                worker = buildworker.LocalBuildWorker(name, 'local', self)
                controller.add_worker(worker)
        else:
            for worker in self.settings['worker']:
                name = controller.generate_worker_name(worker)
                worker = buildworker.RemoteBuildWorker(name, worker, self)
                controller.add_worker(worker)

        result = []

        for repo, ref, filename in self._itertriplets(args):
            # derive a build order from the dependency graph
            graph = BuildDependencyGraph(source_manager, morph_loader,
                                         repo, ref, filename)
            graph.resolve()
            blobs, order = graph.build_order()

            self.msg('Building %s|%s|%s' % (repo, ref, filename))

            # build the tuple and all its dependencies
            result.append(controller.build(blobs, order))

        tempdir.remove()

    def cmd_make_patch(self, args):
        assert os.path.exists(self.settings['cachedir'])
        
        tempdir = morphlib.tempdir.Tempdir(self.settings['tempdir'])
        morph_loader = MorphologyLoader(self.settings)
        src_manager = morphlib.sourcemanager.SourceManager(self, update=False)
        factory = morphlib.builder.Factory(tempdir)
        factory.create_staging()
        builder = morphlib.builder.Builder(tempdir, self, morph_loader,
                                           src_manager, factory)
        #cachedir = morphlib.cachedir.CacheDir(self.settings['cachedir'])
        ex = morphlib.execute.Execute('.', self.msg)

        outpath = args[0]
        args = args[1:]
        trip_iter = self._itertriplets(args)
        paths = {}
        for name in ('source', 'target'):
            repo, ref, filename = trip_iter.next()
            treeish = src_manager.get_treeish(repo, ref)
            morph = morph_loader.load(treeish, filename)
            blob = morphlib.blobs.Blob.create_blob(morph)
            blob_builder = builder.create_blob_builder(blob)
            paths[name] = blob_builder.filename(morph.name)

        try:
            for name in paths.iterkeys():
                # mount the system images
                part = morphlib.fsutils.setup_device_mapping(ex, paths[name])
                mount_point = tempdir.join('mnt_' + name)
                morphlib.fsutils.mount(ex, part, mount_point)

            # make a diff
            ex.runv(['tbdiff-create', outpath,
                     os.path.join(tempdir.join('mnt_source'), 'factory'),
                     os.path.join(tempdir.join('mnt_target'), 'factory')])
        except Exception:
            raise
        finally:
            # cleanup
            for name in paths.iterkeys():
                mount_point = tempdir.join('mnt_' + name)
                try:
                    morphlib.fsutils.unmount(ex, mount_point)
                except:
                    pass
                try:
                    morphlib.fsutils.undo_device_mapping(ex, paths[name])
                except:
                    pass
            factory.remove_staging()

    def cmd_init(self, args):
        '''Initialize a mine.'''
        
        if not args:
            args = ['.']
        elif len(args) > 1:
            raise cliapp.AppException('init must get at most one argument')

        dirname = args[0]

        if os.path.exists(dirname):
            if os.listdir(dirname) != []:
                raise cliapp.AppException('can only initialize empty '
                                          'directory: %s' % dirname)
        else:
            raise cliapp.AppException('can only initialize an existing '
                                        'empty directory: %s' % dirname)

        os.mkdir(os.path.join(dirname, '.morph'))

    def _deduce_mine_directory(self):
        dirname = os.getcwd()
        while dirname != '/':
            dot_morph = os.path.join(dirname, '.morph')
            if os.path.isdir(dot_morph):
                return dirname
            dirname = os.path.dirname(dirname)
        return None

    def cmd_minedir(self, args):
        '''Find morph mine directory from current working directory.'''
        
        dirname = self._deduce_mine_directory()
        if dirname is None:
            raise cliapp.AppException("Can't find the mine directory")
        self.output.write('%s\n' % dirname)
    
    def _clone_to_directory(self, dirname, repo, ref):
        '''Clone a repository below a directory.
        
        As a side effect, clone it into the morph repository.
        
        '''

        # Get the repository into the cache.
        tempdir = morphlib.tempdir.Tempdir(self.settings['tempdir'])
        morph_loader = MorphologyLoader(self.settings)
        source_manager = morphlib.sourcemanager.SourceManager(self,
                                update=not self.settings['no-git-update'])
        treeish = source_manager.get_treeish(repo, ref)
        
        # Clone it from cache to target directory.
        morphlib.git.clone(dirname, treeish.repo, self.msg)
        
        # Set the origin to point at the original repository.
        morphlib.git.set_remote(dirname, 'origin', treeish.original_repo)
        
        # Update remotes.
        self.runcmd(['git', 'remote', 'update'], cwd=dirname)
    
    def cmd_branch(self, args):
        '''Branch the whole system.'''
        
        if len(args) != 1:
            raise cliapp.AppException('morph branch needs name of branch '
                                        'as parameter')

        new_branch = args[0]
        repo = 'morphs'
        commit = 'master'

        # Create the system branch directory.
        os.makedirs(new_branch)

        # Clone into system branch directory.
        new_repo = os.path.join(new_branch, os.path.basename(repo))
        self._clone_to_directory(new_repo, repo, commit)
        
        # Create a new branch in the local morphs repository.
        self.runcmd(['git', 'checkout', '-b', new_branch, commit],
                    cwd=new_repo)

    def cmd_checkout(self, args):
        '''Check out an existing system branch.'''

        if len(args) != 1:
            raise cliapp.AppException('morph checkout needs name of '
                                        'branch as parameter')

        system_branch = args[0]
        repo = 'morphs'

        # Create the system branch directory.
        os.makedirs(system_branch)

        # Clone into system branch directory.
        new_repo = os.path.join(system_branch, os.path.basename(repo))
        self._clone_to_directory(new_repo, repo, system_branch)

    def _deduce_system_branch(self):
        minedir = self._deduce_mine_directory()
        if minedir is None:
            return None

        if not minedir.endswith('/'):
            minedir += '/'
        
        cwd = os.getcwd()
        if not cwd.startswith(minedir):
            return None
            
        return os.path.dirname(cwd[len(minedir):])
    
    def cmd_show_system_branch(self, args):
        '''Print name of current system branch.
        
        This must be run in the system branch's ``morphs`` repository.
        
        '''
        
        system_branch = self._deduce_system_branch()
        if system_branch is None:
            raise cliapp.AppException("Can't determine system branch")
        self.output.write('%s\n' % system_branch)
    
    def cmd_edit(self, args):
        '''Edit a component in a system branch.'''
        
        if len(args) != 2:
            raise cliapp.AppException('morph edit must get a repository name '
                                        'and commit ref as argument')

        repo = args[0]
        ref = args[1]

        mine_directory = self._deduce_mine_directory()
        system_branch = self._deduce_system_branch()
        new_repo = os.path.join(mine_directory, system_branch, 
                                os.path.basename(repo))
        self._clone_to_directory(new_repo, repo, ref)
        
        system_branch = self._deduce_system_branch()
        if system_branch == ref:
            self.runcmd(['git', 'checkout', system_branch],
                        cwd=new_repo)
        else:
            self.runcmd(['git', 'checkout', '-b', system_branch, ref],
                        cwd=new_repo)

    def cmd_merge(self, args):
        '''Merge specified repositories from another system branch.'''
        
        if len(args) == 0:
            raise cliapp.AppException('morph merge must get a branch name '
                                        'and some repo names as arguments')

        other_branch = args[0]
        mine = self._deduce_mine_directory()
        this_branch = self._deduce_system_branch()
        
        for repo in args[1:]:
            basename = os.path.basename(repo)
            pull_from = os.path.join(mine, other_branch, basename)
            repo_dir = os.path.join(mine, this_branch, basename)
            self.runcmd(['git', 'pull', pull_from, other_branch], cwd=repo_dir)

    def cmd_petrify(self, args):
        '''Make refs to chunks be absolute SHA-1s.'''
        
        morph_loader = MorphologyLoader(self.settings)
        source_manager = morphlib.sourcemanager.SourceManager(self,
                            update=not self.settings['no-git-update'])

        for filename in args:
            with open(filename) as f:
                morph = json.load(f)
            
            if morph['kind'] != 'stratum':
                self.msg('Not a stratum: %s' % filename)
                continue

            self.msg('Petrifying %s' % filename)

            for source in morph['sources']:
                repo = source.get('repo', source['name'])
                ref = source['ref']
                self.msg('.. looking up sha1 for %s %s' % (repo, ref))
                treeish = source_manager.get_treeish(repo, ref)
                source['ref'] = treeish.sha1
            
            with open(filename, 'w') as f:
                json.dump(morph, f, indent=2)

    def msg(self, msg):
        '''Show a message to the user about what is going on.'''
        logging.debug(msg)
        if self.settings['verbose']:
            self.output.write('%s\n' % msg)
            self.output.flush()

    def runcmd(self, argv, *args, **kwargs):
        # check which msg function to use
        msg = self.msg
        if 'msg' in kwargs:
            msg = kwargs['msg']
            del kwargs['msg']

        # convert the command line arguments into a string
        commands = [argv] + list(args)
        for command in commands:
            if isinstance(command, list):
                for i in xrange(0, len(command)):
                    command[i] = str(command[i])
        commands = [' '.join(command) for command in commands]

        # print the command line
        msg('# %s' % ' | '.join(commands))

        # run the command line
        return cliapp.Application.runcmd(self, argv, *args, **kwargs)

    # This is in morph so that policy is easily visible, and not embedded
    # deep down in the call stack.
    def clean_env(self):
        '''Create a fresh set of environment variables for a clean build.
        
        Return a dict with the new environment.
        
        '''
        
        path = os.environ['PATH']
        tools = os.environ.get('BOOTSTRAP_TOOLS')
        distcc_hosts = os.environ.get('DISTCC_HOSTS')

        # copy a set of white-listed variables from the original env
        copied_vars = dict.fromkeys([
            'TMPDIR',
            'LD_PRELOAD',
            'LD_LIBRARY_PATH',
            'FAKEROOTKEY',
            'FAKED_MODE',
            'FAKEROOT_FD_BASE',
        ])
        for name in copied_vars:
            copied_vars[name] = os.environ.get(name, None)

        env = {}
        
        # apply the copied variables to the clean env
        for name in copied_vars:
            if copied_vars[name] is not None:
                env[name] = copied_vars[name]

        env['TERM'] = 'dumb'
        env['SHELL'] = '/bin/sh'
        env['USER'] = \
            env['USERNAME'] = \
            env['LOGNAME'] = 'tomjon'
        env['LC_ALL'] = 'C'
        env['HOME'] = '/tmp'

        if self.settings['keep-path'] or self.settings['bootstrap']:
            env['PATH'] = path
        else:
            env['PATH'] = '/sbin:/usr/sbin:/bin:/usr/bin'

        env['TOOLCHAIN_TARGET'] = self.settings['toolchain-target']
        env['CFLAGS'] = self.settings['target-cflags']
        env['PREFIX'] = self.settings['prefix']
        env['BOOTSTRAP'] = 'true' if self.settings['bootstrap'] else 'false'
        if tools is not None:
            env['BOOTSTRAP_TOOLS'] = tools
        if distcc_hosts is not None:
            env['DISTCC_HOSTS'] = distcc_hosts

        if not self.settings['no-ccache']:
            env['PATH'] = ('/usr/lib/ccache:%s' % env['PATH'])
# FIXME: This needs to be made working, but it doesn't really, right now:
# the tempdir is not available inside the staging chroot.
#            env['CCACHE_BASEDIR'] = self.tempdir.dirname
            if not self.settings['no-distcc']:
                env['CCACHE_PREFIX'] = 'distcc'
            
        return env


if __name__ == '__main__':
    Morph().run()
